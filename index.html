<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game - Multiplayer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            padding: 30px;
            text-align: center;
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 20px;
        }

        .current-player {
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
            padding: 10px 20px;
            background: linear-gradient(45deg, #f093fb 0%, #f5576c 100%);
            border-radius: 25px;
            color: white;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .btn-reset {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
        }

        .btn-reset:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(0, 0, 0, 0.3);
        }

        .btn-multiplayer {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
        }

        .btn-multiplayer:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(0, 0, 0, 0.3);
        }

        .multiplayer-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .multiplayer-dialog {
            background: white;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s ease;
            max-width: 500px;
            width: 90%;
        }

        .multiplayer-dialog h3 {
            color: #333;
            margin-bottom: 30px;
            font-size: 1.5em;
        }

        .player-name-section {
            margin-bottom: 20px;
        }

        .player-name-section label {
            display: block;
            margin-bottom: 8px;
            color: #666;
            font-weight: bold;
        }

        .player-name-section input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            text-align: center;
        }

        .player-name-section input:focus {
            outline: none;
            border-color: #667eea;
        }

        .multiplayer-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .btn-create {
            background: linear-gradient(45deg, #56ab2f, #a8e6cf);
            color: white;
        }

        .btn-join-random {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn-join-specific {
            background: linear-gradient(45deg, #f093fb, #f5576c);
            color: white;
        }

        .btn-cancel {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
        }

        .btn-join {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
            margin-top: 10px;
        }

        .join-game-section {
            border-top: 1px solid #eee;
            padding-top: 20px;
        }

        .join-game-section label {
            display: block;
            margin-bottom: 8px;
            color: #666;
            font-weight: bold;
        }

        .join-game-section input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            text-align: center;
            margin-bottom: 10px;
        }

        .game-status-panel {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            min-height: 60px;
        }

        .connection-status {
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        .status-connected {
            color: #16a34a;
            font-weight: bold;
        }

        .status-connecting {
            color: #f59e0b;
            font-weight: bold;
        }

        .status-disconnected {
            color: #dc2626;
            font-weight: bold;
        }

        .game-info-panel {
            font-size: 0.9em;
            color: #666;
        }

        .player-indicator {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
            margin-left: 10px;
        }

        .player-white {
            background: #f0f0f0;
            color: #333;
        }

        .player-black {
            background: #333;
            color: #fff;
        }

        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 70px);
            grid-template-rows: repeat(8, 70px);
            border: 4px solid #8b4513;
            border-radius: 10px;
            margin: 20px auto;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
            background: #8b4513;
            overflow: hidden;
        }

        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5em;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            user-select: none;
        }

        .square.light {
            background-color: #f0d9b5;
        }

        .square.dark {
            background-color: #b58863;
        }

        .square.selected {
            background-color: #7dd3fc !important;
            box-shadow: inset 0 0 0 4px #0284c7;
        }

        .square.valid-move {
            background-color: #86efac !important;
            box-shadow: inset 0 0 0 3px #16a34a;
        }

        .square.valid-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: #16a34a;
            border-radius: 50%;
            opacity: 0.7;
        }

        .square.capture-move {
            background-color: #fca5a5 !important;
            box-shadow: inset 0 0 0 3px #dc2626;
        }

        .square:hover {
            transform: scale(1.05);
            z-index: 1;
        }

        .piece {
            transition: all 0.3s ease;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .piece.white {
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .piece.black {
            color: #222;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.3);
        }

        .status {
            margin-top: 20px;
            font-size: 1.1em;
            color: #333;
            min-height: 30px;
        }

        .check-warning {
            color: #dc2626;
            font-weight: bold;
            animation: pulse 1s infinite;
        }

        .checkmate {
            color: #dc2626;
            font-weight: bold;
            font-size: 1.3em;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .game-bottom {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .captured-pieces {
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex: 1;
            min-width: 200px;
        }

        .captured-section {
            min-height: 60px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 10px;
            padding: 10px;
        }

        .captured-section h3 {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .captured-pieces-list {
            font-size: 1.5em;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .move-history {
            flex: 1;
            min-width: 300px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 10px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .move-history h3 {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-align: center;
        }

        .moves-list {
            display: grid;
            grid-template-columns: auto 1fr 1fr;
            gap: 5px 15px;
            font-size: 0.9em;
            text-align: left;
        }

        .move-number {
            color: #888;
            font-weight: bold;
            text-align: center;
        }

        .move-item {
            color: #333;
            padding: 2px 8px;
            border-radius: 4px;
            transition: background-color 0.2s ease;
        }

        .move-item:hover {
            background-color: rgba(0, 0, 0, 0.1);
        }

        .move-item.white-move {
            background-color: rgba(255, 255, 255, 0.3);
        }

        .move-item.black-move {
            background-color: rgba(0, 0, 0, 0.1);
        }

        .promotion-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .promotion-dialog {
            background: white;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s ease;
        }

        .promotion-dialog h3 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.3em;
        }

        .promotion-options {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .promotion-piece {
            font-size: 3em;
            padding: 15px;
            border: 3px solid transparent;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(0, 0, 0, 0.05);
        }

        .promotion-piece:hover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
            transform: scale(1.1);
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @media (max-width: 768px) {
            .chessboard {
                grid-template-columns: repeat(8, 50px);
                grid-template-rows: repeat(8, 50px);
            }
            
            .square {
                font-size: 2em;
            }
            
            .game-info {
                flex-direction: column;
                text-align: center;
            }

            .game-bottom {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>♕ Chess Game ♛</h1>
        
        <div class="game-info">
            <div class="current-player" id="currentPlayer">White's Turn</div>
            <div class="controls">
                <button class="btn btn-reset" onclick="resetGame()">New Game</button>
                <button class="btn btn-multiplayer" onclick="showMultiplayerMenu()">Multiplayer</button>
            </div>
        </div>

        <!-- Game Status Panel -->
        <div class="game-status-panel" id="gameStatusPanel">
            <div class="connection-status" id="connectionStatus">Local Game Mode</div>
            <div class="game-info-panel" id="gameInfoPanel"></div>
        </div>

        <!-- Multiplayer Menu Modal -->
        <div class="multiplayer-modal" id="multiplayerModal" style="display: none;">
            <div class="multiplayer-dialog">
                <h3>Multiplayer Options</h3>
                <div class="multiplayer-options">
                    <div class="player-name-section">
                        <label for="playerNameInput">Your Name:</label>
                        <input type="text" id="playerNameInput" placeholder="Enter your name" maxlength="20">
                    </div>
                    <div class="multiplayer-buttons">
                        <button class="btn btn-create" onclick="createMultiplayerGame()">Create Game</button>
                        <button class="btn btn-join-random" onclick="joinRandomGame()">Join Random Game</button>
                        <button class="btn btn-join-specific" onclick="showJoinGameDialog()">Join Specific Game</button>
                        <button class="btn btn-cancel" onclick="closeMultiplayerMenu()">Cancel</button>
                    </div>
                    <div class="join-game-section" id="joinGameSection" style="display: none;">
                        <label for="gameIdInput">Game ID:</label>
                        <input type="text" id="gameIdInput" placeholder="Enter Game ID">
                        <button class="btn btn-join" onclick="joinSpecificGame()">Join</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="chessboard" id="chessboard"></div>
        
        <div class="status" id="gameStatus"></div>
        
        <div class="game-bottom">
            <div class="captured-pieces">
                <div class="captured-section">
                    <h3>Captured White Pieces</h3>
                    <div class="captured-pieces-list" id="capturedWhite"></div>
                </div>
                <div class="captured-section">
                    <h3>Captured Black Pieces</h3>
                    <div class="captured-pieces-list" id="capturedBlack"></div>
                </div>
            </div>
            
            <div class="move-history">
                <h3>Move History</h3>
                <div class="moves-list" id="movesList"></div>
            </div>
        </div>

        <!-- Promotion Modal -->
        <div class="promotion-modal" id="promotionModal" style="display: none;">
            <div class="promotion-dialog">
                <h3>Choose promotion piece:</h3>
                <div class="promotion-options" id="promotionOptions">
                </div>
            </div>
        </div>
    </div>

  
    <!-- Include SockJS and STOMP for WebSocket communication -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.6.1/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>

    <script>
        const BACKEND_URL = 'https://chess-backend-hu0h.onrender.com/api';

        
        class ChessGame {
            constructor() {
                this.board = this.initializeBoard();
                this.currentPlayer = 'white';
                this.selectedSquare = null;
                this.gameOver = false;
                this.capturedPieces = { white: [], black: [] };
                this.kings = { white: { row: 7, col: 4 }, black: { row: 0, col: 4 } };
                this.moveHistory = [];
                this.lastMove = null;
                this.pendingPromotion = null;
                
                // Multiplayer properties
                this.isMultiplayer = false;
                this.playerId = this.generatePlayerId();
                this.playerName = '';
                this.playerColor = null;
                this.gameId = null;
                this.stompClient = null;
                this.connected = false;
                
                this.initializeGame();
            }

            generatePlayerId() {
                return 'player_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
            }

            // WebSocket connection methods
            connectToServer() {
                return new Promise((resolve, reject) => {
                    try {
                        const socket = new SockJS(BACKEND_URL + '/chess-websocket');
                        this.stompClient = Stomp.over(socket);
                        
                        this.updateGameStatus('Connecting to server...', 'connecting');
                        
                        this.stompClient.connect({}, 
                            (frame) => {
                                console.log('Connected: ' + frame);
                                this.connected = true;
                                this.updateGameStatus('Connected to server', 'connected');
                                resolve();
                            },
                            (error) => {
                                console.log('Connection error: ' + error);
                                this.connected = false;
                                this.updateGameStatus('Failed to connect to server', 'disconnected');
                                reject(error);
                            }
                        );
                    } catch (error) {
                        this.updateGameStatus('Failed to connect to server', 'disconnected');
                        reject(error);
                    }
                });
            }

            disconnectFromServer() {
                if (this.stompClient && this.connected) {
                    // Send disconnect message
                    if (this.gameId) {
                        const disconnectMessage = {
                            type: 'disconnect',
                            playerId: this.playerId,
                            playerName: this.playerName
                        };
                        this.stompClient.send(`/app/game/${this.gameId}/disconnect`, {}, JSON.stringify(disconnectMessage));
                    }
                    
                    this.stompClient.disconnect();
                    this.connected = false;
                    this.updateGameStatus('Disconnected from server', 'disconnected');
                }
            }

            subscribeToGame(gameId) {
                if (!this.stompClient || !this.connected) return;

                // Subscribe to general game updates
                this.stompClient.subscribe(`/topic/game/${gameId}`, (message) => {
                    const gameMessage = JSON.parse(message.body);
                    this.handleGameMessage(gameMessage);
                });

                // Subscribe to player-specific messages
                this.stompClient.subscribe(`/topic/game/${gameId}/player/${this.playerId}`, (message) => {
                    const gameMessage = JSON.parse(message.body);
                    this.handlePlayerMessage(gameMessage);
                });
            }

            handleGameMessage(message) {
                console.log('Game message received:', message);
                switch (message.type) {
                    case 'move':
                        this.handleRemoteMove(message);
                        break;
                    case 'playerJoined':
                        this.updateGameInfo(`${message.playerName} joined the game`);
                        if (message.gameState) {
                            this.updateFromGameState(message.gameState);
                        }
                        break;
                    case 'playerDisconnected':
                        this.updateGameInfo(`${message.playerName} disconnected`);
                        break;
                    case 'gameStart':
                        this.updateGameInfo('Game started! Both players connected.');
                        if (message.gameState) {
                            this.updateFromGameState(message.gameState);
                        }
                        break;
                    case 'gameEnd':
                        this.handleGameEnd(message.gameState);
                        break;
                }
            }

            handlePlayerMessage(message) {
                console.log('Player message received:', message);
                switch (message.type) {
                    case 'gameJoined':
                        this.handleGameJoined(message.gameState);
                        break;
                    case 'error':
                        alert('Error: ' + message.error);
                        break;
                }
            }

            updateGameStatus(status, type = 'info') {
                const statusElement = document.getElementById('connectionStatus');
                statusElement.textContent = status;
                statusElement.className = `connection-status status-${type}`;
            }

            updateGameInfo(info) {
                const infoElement = document.getElementById('gameInfoPanel');
                infoElement.textContent = info;
            }

            // Multiplayer game creation and joining
            async createMultiplayerGame() {
                const playerName = document.getElementById('playerNameInput').value.trim();
                if (!playerName) {
                    alert('Please enter your name');
                    return;
                }

                this.playerName = playerName;
                
                try {
                    await this.connectToServer();
                    
                    const response = await fetch(`${BACKEND_URL}/api/games/create`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            playerId: this.playerId,
                            playerName: this.playerName
                        })
                    });

                    if (response.ok) {
                        const gameSession = await response.json();
                        this.gameId = gameSession.gameId;
                        this.isMultiplayer = true;
                        this.playerColor = 'white'; // Creator is always white
                        
                        this.subscribeToGame(this.gameId);
                        this.updateGameInfo(`Game created! Share this ID: ${this.gameId}. Waiting for opponent...`);
                        
                        closeMultiplayerMenu();
                    } else {
                        throw new Error('Failed to create game');
                    }
                } catch (error) {
                    console.error('Error creating game:', error);
                    alert('Failed to create game. Make sure the server is running on localhost:8080');
                }
            }

            async joinRandomGame() {
                const playerName = document.getElementById('playerNameInput').value.trim();
                if (!playerName) {
                    alert('Please enter your name');
                    return;
                }

                this.playerName = playerName;
                
                try {
                    await this.connectToServer();

                    const response = await fetch(`${BACKEND_URL}/api/games/join-random`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            playerId: this.playerId,
                            playerName: this.playerName
                        })
                    });

                    if (response.ok) {
                        const gameSession = await response.json();
                        if (gameSession) {
                            this.handleGameJoined(gameSession);
                            closeMultiplayerMenu();
                        } else {
                            alert('No available games to join. Try creating a new game.');
                        }
                    } else {
                        throw new Error('Failed to join random game');
                    }
                } catch (error) {
                    console.error('Error joining random game:', error);
                    alert('Failed to join game. Make sure the server is running on localhost:8080');
                }
            }

            async joinSpecificGame() {
                const playerName = document.getElementById('playerNameInput').value.trim();
                const gameId = document.getElementById('gameIdInput').value.trim();
                
                if (!playerName) {
                    alert('Please enter your name');
                    return;
                }
                
                if (!gameId) {
                    alert('Please enter a game ID');
                    return;
                }

                this.playerName = playerName;
                this.gameId = gameId;
                
                try {
                    await this.connectToServer();

                    // Send join message via WebSocket
                    const joinMessage = {
                        type: 'join',
                        playerId: this.playerId,
                        playerName: this.playerName
                    };

                    this.subscribeToGame(this.gameId);
                    this.stompClient.send(`/app/game/${this.gameId}/join`, {}, JSON.stringify(joinMessage));
                    this.updateGameInfo(`Attempting to join game ${this.gameId}...`);
                    closeMultiplayerMenu();
                } catch (error) {
                    console.error('Error joining specific game:', error);
                    alert('Failed to connect to game. Make sure the server is running and the game ID is correct.');
                }
            }

            handleGameJoined(gameState) {
                this.isMultiplayer = true;
                this.gameId = gameState.gameId;
                
                // Determine player color
                if (gameState.whitePlayer && gameState.whitePlayer.id === this.playerId) {
                    this.playerColor = 'white';
                } else if (gameState.blackPlayer && gameState.blackPlayer.id === this.playerId) {
                    this.playerColor = 'black';
                }

                this.updateGameInfo(`You are playing as ${this.playerColor}. Game ID: ${this.gameId}`);
                
                if (gameState.gameStatus === 'active') {
                    this.updateGameInfo(`Game started! You are ${this.playerColor}`);
                } else {
                    this.updateGameInfo(`Waiting for opponent... Share game ID: ${this.gameId}`);
                }
            }

            handleRemoteMove(message) {
                if (message.move) {
                    const move = message.move;
                    // Apply the move locally (without validation since it's from server)
                    this.applyMoveFromServer(move);
                    
                    if (message.gameState) {
                        this.currentPlayer = message.gameState.currentTurn;
                        this.updateStatus();
                    }
                }
            }

            applyMoveFromServer(move) {
                const piece = this.board[move.fromRow][move.fromCol];
                const capturedPiece = this.board[move.toRow][move.toCol];
                
                if (capturedPiece) {
                    this.capturedPieces[capturedPiece.color].push(capturedPiece);
                }
                
                this.board[move.toRow][move.toCol] = piece;
                this.board[move.fromRow][move.fromCol] = null;
                
                if (piece && piece.type === 'king') {
                    this.kings[piece.color] = { row: move.toRow, col: move.toCol };
                }
                
                // Add to move history
                this.moveHistory.push({
                    player: move.playerColor,
                    notation: move.notation,
                    fullMove: Math.floor(this.moveHistory.length / 2) + 1
                });
                
                this.updateDisplay();
            }

            sendMove(fromRow, fromCol, toRow, toCol) {
                if (!this.isMultiplayer || !this.stompClient || !this.connected) return;

                const piece = this.board[fromRow][fromCol];
                const capturedPiece = this.board[toRow][toCol];
                
                const move = {
                    fromRow,
                    fromCol,
                    toRow,
                    toCol,
                    playerId: this.playerId,
                    playerColor: this.playerColor,
                    piece: piece.type,
                    capturedPiece: capturedPiece ? capturedPiece.type : null,
                    notation: this.generateNotation(fromRow, fromCol, toRow, toCol),
                    timestamp: new Date().toISOString()
                };

                const moveMessage = {
                    type: 'move',
                    playerId: this.playerId,
                    move: move
                };

                this.stompClient.send(`/app/game/${this.gameId}/move`, {}, JSON.stringify(moveMessage));
            }

            generateNotation(fromRow, fromCol, toRow, toCol) {
                const piece = this.board[fromRow][fromCol];
                const captured = this.board[toRow][toCol];
                const fromSquare = String.fromCharCode(97 + fromCol) + (8 - fromRow);
                const toSquare = String.fromCharCode(97 + toCol) + (8 - toRow);
                
                let notation = '';
                if (piece.type === 'pawn') {
                    if (captured) {
                        notation = fromSquare[0] + 'x' + toSquare;
                    } else {
                        notation = toSquare;
                    }
                } else {
                    const pieceSymbol = piece.type.charAt(0).toUpperCase();
                    if (captured) {
                        notation = pieceSymbol + 'x' + toSquare;
                    } else {
                        notation = pieceSymbol + toSquare;
                    }
                }
                
                return notation;
            }

            handleGameEnd(gameState) {
                this.gameOver = true;
                const winner = gameState.winner;
                let message = '';
                
                if (winner === 'draw') {
                    message = 'Game ended in a draw';
                } else {
                    message = `${winner.charAt(0).toUpperCase() + winner.slice(1)} wins!`;
                }
                
                document.getElementById('gameStatus').innerHTML = `<span class="checkmate">${message}</span>`;
            }

            resetToLocal() {
                this.isMultiplayer = false;
                this.disconnectFromServer();
                this.gameId = null;
                this.playerColor = null;
                this.updateGameStatus('Local Game Mode');
                this.updateGameInfo('');
            }

            initializeBoard() {
                const board = Array(8).fill(null).map(() => Array(8).fill(null));
                
                // Place pawns
                for (let col = 0; col < 8; col++) {
                    board[1][col] = { type: 'pawn', color: 'black' };
                    board[6][col] = { type: 'pawn', color: 'white' };
                }
                
                // Place other pieces
                const backRow = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
                for (let col = 0; col < 8; col++) {
                    board[0][col] = { type: backRow[col], color: 'black' };
                    board[7][col] = { type: backRow[col], color: 'white' };
                }
                
                return board;
            }

            initializeGame() {
                this.renderBoard();
                this.updateStatus();
            }

            renderBoard() {
                const chessboard = document.getElementById('chessboard');
                chessboard.innerHTML = '';

                //flip the board function
                const flipBoard =this.isMultiplayer && this.playerColor === 'black';
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {

                        const actualRow =flipBoard ? 7 - row : row;
                        const actualCol =flipBoard ? 7 -col : col;

                        const square = document.createElement('div');
                        square.className = `square ${(actualRow + actualCol) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.actualRow = actualRow;
                        square.dataset.actualCol = actualCol;
                        square.onclick = () => this.handleSquareClick(actualRow, actualCol);
                        
                        const piece = this.board[actualRow][actualCol];
                        if (piece) {
                            const pieceElement = document.createElement('span');
                            pieceElement.className = `piece ${piece.color}`;
                            pieceElement.textContent = this.getPieceSymbol(piece);
                            square.appendChild(pieceElement);
                        }
                        
                        chessboard.appendChild(square);
                    }
                }
            }

            getPieceSymbol(piece) {
                const symbols = {
                    white: {
                        king: '♔',
                        queen: '♕',
                        rook: '♖',
                        bishop: '♗',
                        knight: '♘',
                        pawn: '♙'
                    },
                    black: {
                        king: '♚',
                        queen: '♛',
                        rook: '♜',
                        bishop: '♝',
                        knight: '♞',
                        pawn: '♟'
                    }
                };
                return symbols[piece.color][piece.type];
            }

            handleSquareClick(row, col) {
                if (this.gameOver || this.pendingPromotion) return;
                
                // In multiplayer, only allow moves when it's your turn
                if (this.isMultiplayer && this.playerColor !== this.currentPlayer) {
                    this.updateGameInfo('It\'s not your turn!');
                    return;
                }
                
                const piece = this.board[row][col];
                
                if (this.selectedSquare) {
                    const [selectedRow, selectedCol] = this.selectedSquare;
                    
                    if (row === selectedRow && col === selectedCol) {
                        this.clearSelection();
                        return;
                    }
                    
                    if (this.isValidMove(selectedRow, selectedCol, row, col)) {
                        if (this.isMultiplayer) {
                            this.sendMove(selectedRow, selectedCol, row, col);
                            // Don't apply move locally - wait for server confirmation
                        } else {
                            this.makeMove(selectedRow, selectedCol, row, col);
                        }
                        this.clearSelection();
                    } else {
                        if (piece && piece.color === this.currentPlayer) {
                            // In multiplayer, only select own pieces
                            if (!this.isMultiplayer || piece.color === this.playerColor) {
                                this.selectSquare(row, col);
                            }
                        } else {
                            this.clearSelection();
                        }
                    }
                } else {
                    if (piece && piece.color === this.currentPlayer) {
                        // In multiplayer, only select own pieces
                        if (!this.isMultiplayer || piece.color === this.playerColor) {
                            this.selectSquare(row, col);
                        }
                    }
                }
            }

            selectSquare(row, col) {
                this.clearHighlights();
                this.selectedSquare = [row, col];
                this.highlightSquare(row, col, 'selected');
                this.highlightValidMoves(row, col);
            }

            clearSelection() {
                this.selectedSquare = null;
                this.clearHighlights();
            }

           highlightSquare(row, col, className) {
               const square = document.querySelector(`[data-actual-row="${row}"][data-actual-col="${col}"]`);
                   if (square) square.classList.add(className);
            }

            clearHighlights() {
                document.querySelectorAll('.square').forEach(square => {
                    square.classList.remove('selected', 'valid-move', 'capture-move');
                });
            }

            highlightValidMoves(row, col) {
                const validMoves = this.getValidMoves(row, col);
                validMoves.forEach(([moveRow, moveCol]) => {
                    const targetPiece = this.board[moveRow][moveCol];
                    const className = targetPiece ? 'capture-move' : 'valid-move';
                    this.highlightSquare(moveRow, moveCol, className);
                });
            }

            getValidMoves(row, col) {
                const piece = this.board[row][col];
                if (!piece) return [];

                let moves = [];
                
                switch (piece.type) {
                    case 'pawn':
                        moves = this.getPawnMoves(row, col, piece.color);
                        break;
                    case 'rook':
                        moves = this.getRookMoves(row, col);
                        break;
                    case 'knight':
                        moves = this.getKnightMoves(row, col);
                        break;
                    case 'bishop':
                        moves = this.getBishopMoves(row, col);
                        break;
                    case 'queen':
                        moves = [...this.getRookMoves(row, col), ...this.getBishopMoves(row, col)];
                        break;
                    case 'king':
                        moves = this.getKingMoves(row, col);
                        break;
                }

                // Filter out moves that would put own king in check
                return moves.filter(([toRow, toCol]) => !this.wouldBeInCheck(row, col, toRow, toCol, piece.color));
            }

            getPawnMoves(row, col, color) {
                const moves = [];
                const direction = color === 'white' ? -1 : 1;
                const startRow = color === 'white' ? 6 : 1;

                // Move forward one square
                if (this.isValidSquare(row + direction, col) && !this.board[row + direction][col]) {
                    moves.push([row + direction, col]);
                    
                    // Move forward two squares from starting position
                    if (row === startRow && !this.board[row + 2 * direction][col]) {
                        moves.push([row + 2 * direction, col]);
                    }
                }

                // Capture diagonally
                for (const dcol of [-1, 1]) {
                    const newRow = row + direction;
                    const newCol = col + dcol;
                    if (this.isValidSquare(newRow, newCol)) {
                        const targetPiece = this.board[newRow][newCol];
                        if (targetPiece && targetPiece.color !== color) {
                            moves.push([newRow, newCol]);
                        }
                        // En passant
                        else if (this.isEnPassant(row, col, newRow, newCol, color)) {
                            moves.push([newRow, newCol]);
                        }
                    }
                }

                return moves;
            }

            getRookMoves(row, col) {
                const moves = [];
                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

                for (const [drow, dcol] of directions) {
                    for (let i = 1; i < 8; i++) {
                        const newRow = row + i * drow;
                        const newCol = col + i * dcol;
                        
                        if (!this.isValidSquare(newRow, newCol)) break;
                        
                        const targetPiece = this.board[newRow][newCol];
                        if (!targetPiece) {
                            moves.push([newRow, newCol]);
                        } else {
                            if (targetPiece.color !== this.board[row][col].color) {
                                moves.push([newRow, newCol]);
                            }
                            break;
                        }
                    }
                }

                return moves;
            }

            getBishopMoves(row, col) {
                const moves = [];
                const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];

                for (const [drow, dcol] of directions) {
                    for (let i = 1; i < 8; i++) {
                        const newRow = row + i * drow;
                        const newCol = col + i * dcol;
                        
                        if (!this.isValidSquare(newRow, newCol)) break;
                        
                        const targetPiece = this.board[newRow][newCol];
                        if (!targetPiece) {
                            moves.push([newRow, newCol]);
                        } else {
                            if (targetPiece.color !== this.board[row][col].color) {
                                moves.push([newRow, newCol]);
                            }
                            break;
                        }
                    }
                }

                return moves;
            }

            getKnightMoves(row, col) {
                const moves = [];
                const knightMoves = [
                    [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                    [1, -2], [1, 2], [2, -1], [2, 1]
                ];

                for (const [drow, dcol] of knightMoves) {
                    const newRow = row + drow;
                    const newCol = col + dcol;
                    
                    if (this.isValidSquare(newRow, newCol)) {
                        const targetPiece = this.board[newRow][newCol];
                        if (!targetPiece || targetPiece.color !== this.board[row][col].color) {
                            moves.push([newRow, newCol]);
                        }
                    }
                }

                return moves;
            }

            getKingMoves(row, col) {
                const moves = [];
                const kingMoves = [
                    [-1, -1], [-1, 0], [-1, 1],
                    [0, -1], [0, 1],
                    [1, -1], [1, 0], [1, 1]
                ];

                for (const [drow, dcol] of kingMoves) {
                    const newRow = row + drow;
                    const newCol = col + dcol;
                    
                    if (this.isValidSquare(newRow, newCol)) {
                        const targetPiece = this.board[newRow][newCol];
                        if (!targetPiece || targetPiece.color !== this.board[row][col].color) {
                            moves.push([newRow, newCol]);
                        }
                    }
                }

                // Add castling moves
                   if (this.canCastle(row, col, 'kingside')) {
                      moves.push([row, col + 2]);
                    }
                   if (this.canCastle(row, col, 'queenside')) {
                      moves.push([row, col - 2]);
                    }

                return moves;
            }

            canCastle(kingRow, kingCol, side) {
                 const piece = this.board[kingRow][kingCol];
                 if (!piece || piece.type !== 'king') return false;
    
                 const color = piece.color;
                 const expectedRow = color === 'white' ? 7 : 0;
                 const expectedCol = 4;
    
                // King must be on starting square
                if (kingRow !== expectedRow || kingCol !== expectedCol) return false;
    
                // King must not be in check
                const enemyColor = color === 'white' ? 'black' : 'white';
                if (this.isSquareAttacked(kingRow, kingCol, enemyColor)) return false;
    
                const rookCol = side === 'kingside' ? 7 : 0;
                const rook = this.board[expectedRow][rookCol];
    
                // Rook must be present and unmoved
                 if (!rook || rook.type !== 'rook' || rook.color !== color) return false;
    
                   // Path must be clear
                    const startCol = side === 'kingside' ? kingCol + 1 : rookCol + 1;
                    const endCol = side === 'kingside' ? rookCol : kingCol;
    
                    for (let col = startCol; col < endCol; col++) {
                        if (this.board[expectedRow][col]) return false;
                        // Squares king passes through must not be attacked
                        if (col >= kingCol - 1 && col <= kingCol + 1) {
                     if (this.isSquareAttacked(expectedRow, col, enemyColor)) return false;
                     }
                }
    
              return true;
            }

            isValidSquare(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }

            isValidMove(fromRow, fromCol, toRow, toCol) {
                const validMoves = this.getValidMoves(fromRow, fromCol);
                return validMoves.some(([r, c]) => r === toRow && c === toCol);
            }

            wouldBeInCheck(fromRow, fromCol, toRow, toCol, color) {
                // Make a temporary move
                const originalPiece = this.board[toRow][toCol];
                const movingPiece = this.board[fromRow][fromCol];
                this.board[toRow][toCol] = movingPiece;
                this.board[fromRow][fromCol] = null;

                // Update king position if king is moving
                let kingRow = this.kings[color].row;
                let kingCol = this.kings[color].col;
                if (movingPiece.type === 'king') {
                    kingRow = toRow;
                    kingCol = toCol;
                }

                // Check if king would be in check
                const inCheck = this.isSquareAttacked(kingRow, kingCol, color === 'white' ? 'black' : 'white');

                // Restore the board
                this.board[fromRow][fromCol] = movingPiece;
                this.board[toRow][toCol] = originalPiece;

                return inCheck;
            }

            isSquareAttacked(row, col, byColor) {
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = this.board[r][c];
                        if (piece && piece.color === byColor) {
                            if (this.canPieceAttackSquare(r, c, row, col)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            canPieceAttackSquare(pieceRow, pieceCol, targetRow, targetCol) {
                const piece = this.board[pieceRow][pieceCol];
                if (!piece) return false;

                switch (piece.type) {
                    case 'pawn':
                        return this.canPawnAttack(pieceRow, pieceCol, targetRow, targetCol, piece.color);
                    case 'rook':
                        return this.canRookAttack(pieceRow, pieceCol, targetRow, targetCol);
                    case 'bishop':
                        return this.canBishopAttack(pieceRow, pieceCol, targetRow, targetCol);
                    case 'knight':
                        return this.canKnightAttack(pieceRow, pieceCol, targetRow, targetCol);
                    case 'queen':
                        return this.canRookAttack(pieceRow, pieceCol, targetRow, targetCol) || 
                               this.canBishopAttack(pieceRow, pieceCol, targetRow, targetCol);
                    case 'king':
                        return this.canKingAttack(pieceRow, pieceCol, targetRow, targetCol);
                    default:
                        return false;
                }
            }

            canPawnAttack(row, col, targetRow, targetCol, color) {
                const direction = color === 'white' ? -1 : 1;
                return targetRow === row + direction && Math.abs(targetCol - col) === 1;
            }

            canRookAttack(row, col, targetRow, targetCol) {
                if (row !== targetRow && col !== targetCol) return false;
                
                const rowStep = row === targetRow ? 0 : (targetRow > row ? 1 : -1);
                const colStep = col === targetCol ? 0 : (targetCol > col ? 1 : -1);
                
                let currentRow = row + rowStep;
                let currentCol = col + colStep;
                
                while (currentRow !== targetRow || currentCol !== targetCol) {
                    if (this.board[currentRow][currentCol]) return false;
                    currentRow += rowStep;
                    currentCol += colStep;
                }
                
                return true;
            }

            canBishopAttack(row, col, targetRow, targetCol) {
                if (Math.abs(targetRow - row) !== Math.abs(targetCol - col)) return false;
                
                const rowStep = targetRow > row ? 1 : -1;
                const colStep = targetCol > col ? 1 : -1;
                
                let currentRow = row + rowStep;
                let currentCol = col + colStep;
                
                while (currentRow !== targetRow || currentCol !== targetCol) {
                    if (this.board[currentRow][currentCol]) return false;
                    currentRow += rowStep;
                    currentCol += colStep;
                }
                
                return true;
            }

            canKnightAttack(row, col, targetRow, targetCol) {
                const rowDiff = Math.abs(targetRow - row);
                const colDiff = Math.abs(targetCol - col);
                return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
            }

            canKingAttack(row, col, targetRow, targetCol) {
                const rowDiff = Math.abs(targetRow - row);
                const colDiff = Math.abs(targetCol - col);
                return rowDiff <= 1 && colDiff <= 1 && (rowDiff > 0 || colDiff > 0);
            }

            isEnPassant(row, col, targetRow, targetCol, color) {
                // Check if last move was a pawn moving two squares
                if (!this.lastMove) return false;
                
                const { from, to, piece } = this.lastMove;
                if (piece.type !== 'pawn') return false;
                if (Math.abs(from[0] - to[0]) !== 2) return false;
                
                // Check if the target square is behind the enemy pawn
                const enemyRow = color === 'white' ? 3 : 4;
                if (row !== enemyRow) return false;
                if (to[1] !== targetCol) return false;
                if (to[0] !== row) return false;
                
                return true;
            }

            makeMove(fromRow, fromCol, toRow, toCol) {
                const piece = this.board[fromRow][fromCol];
                const capturedPiece = this.board[toRow][toCol];
                
                // Handle castling
                if (piece.type === 'king' && Math.abs(toCol - fromCol) === 2) {
                    this.performCastling(fromRow, fromCol, toRow, toCol);
                    this.switchPlayer();
                    this.updateDisplay();
                    return;
                }
                
                // Handle en passant
                if (piece.type === 'pawn' && this.isEnPassant(fromRow, fromCol, toRow, toCol, piece.color)) {
                    const capturedPawnRow = piece.color === 'white' ? 3 : 4;
                    const capturedPawn = this.board[capturedPawnRow][toCol];
                    this.board[capturedPawnRow][toCol] = null;
                    this.capturedPieces[capturedPawn.color].push(capturedPawn);
                }
                
                // Capture piece if present
                if (capturedPiece) {
                    this.capturedPieces[capturedPiece.color].push(capturedPiece);
                }
                
                // Move the piece
                this.board[toRow][toCol] = piece;
                this.board[fromRow][fromCol] = null;
                
                // Update king position
                if (piece.type === 'king') {
                    this.kings[piece.color] = { row: toRow, col: toCol };
                }
                
                // Record the move
                this.lastMove = {
                    from: [fromRow, fromCol],
                    to: [toRow, toCol],
                    piece: piece,
                    captured: capturedPiece
                };
                
                // Handle pawn promotion
                if (piece.type === 'pawn' && (toRow === 0 || toRow === 7)) {
                    this.pendingPromotion = { row: toRow, col: toCol, color: piece.color };
                    this.showPromotionDialog(piece.color);
                    return;
                }
                
                // Add move to history
                this.addMoveToHistory(fromRow, fromCol, toRow, toCol, piece, capturedPiece);
                
                this.switchPlayer();
                this.updateDisplay();
            }

            performCastling(fromRow, fromCol, toRow, toCol) {
                const king = this.board[fromRow][fromCol];
                const side = toCol > fromCol ? 'kingside' : 'queenside';
                const rookFromCol = side === 'kingside' ? 7 : 0;
                const rookToCol = side === 'kingside' ? 5 : 3;
                
                // Move king
                this.board[toRow][toCol] = king;
                this.board[fromRow][fromCol] = null;
                this.kings[king.color] = { row: toRow, col: toCol };
                
                // Move rook
                const rook = this.board[fromRow][rookFromCol];
                this.board[fromRow][rookToCol] = rook;
                this.board[fromRow][rookFromCol] = null;
                
                // Add move to history
                const notation = side === 'kingside' ? 'O-O' : 'O-O-O';
                this.moveHistory.push({
                    player: this.currentPlayer,
                    notation: notation,
                    fullMove: Math.floor(this.moveHistory.length / 2) + 1
                });
            }

            showPromotionDialog(color) {
                const modal = document.getElementById('promotionModal');
                const options = document.getElementById('promotionOptions');
                
                options.innerHTML = '';
                const pieces = ['queen', 'rook', 'bishop', 'knight'];
                
                pieces.forEach(pieceType => {
                    const option = document.createElement('div');
                    option.className = 'promotion-piece';
                    option.textContent = this.getPieceSymbol({ type: pieceType, color: color });
                    option.onclick = () => this.promoteTopiece(pieceType);
                    options.appendChild(option);
                });
                
                modal.style.display = 'flex';
            }

            promoteTopiece(pieceType) {
                const { row, col, color } = this.pendingPromotion;
                this.board[row][col] = { type: pieceType, color: color };
                
                // Add move to history
                const moveCount = this.moveHistory.length;
                if (moveCount > 0) {
                    this.moveHistory[moveCount - 1].notation += '=' + pieceType.charAt(0).toUpperCase();
                }
                
                this.pendingPromotion = null;
                document.getElementById('promotionModal').style.display = 'none';
                
                this.switchPlayer();
                this.updateDisplay();
            }

            addMoveToHistory(fromRow, fromCol, toRow, toCol, piece, captured) {
                const fromSquare = String.fromCharCode(97 + fromCol) + (8 - fromRow);
                const toSquare = String.fromCharCode(97 + toCol) + (8 - toRow);
                
                let notation = '';
                if (piece.type === 'pawn') {
                    if (captured) {
                        notation = fromSquare[0] + 'x' + toSquare;
                    } else {
                        notation = toSquare;
                    }
                } else {
                    const pieceSymbol = piece.type.charAt(0).toUpperCase();
                    if (captured) {
                        notation = pieceSymbol + 'x' + toSquare;
                    } else {
                        notation = pieceSymbol + toSquare;
                    }
                }
                
                this.moveHistory.push({
                    player: this.currentPlayer,
                    notation: notation,
                    fullMove: Math.floor(this.moveHistory.length / 2) + 1
                });
            }

            switchPlayer() {
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
            }

            updateDisplay() {
                this.renderBoard();
                this.updateStatus();
                this.updateCapturedPieces();
                this.updateMoveHistory();
            }

            updateStatus() {
                const statusElement = document.getElementById('gameStatus');
                const currentPlayerElement = document.getElementById('currentPlayer');
                
                if (this.gameOver) {
                    return;
                }
                
                // Check for check and checkmate
                const enemyColor = this.currentPlayer === 'white' ? 'black' : 'white';
                const kingPos = this.kings[this.currentPlayer];
                const inCheck = this.isSquareAttacked(kingPos.row, kingPos.col, enemyColor);
                
                if (inCheck) {
                    if (this.isCheckmate(this.currentPlayer)) {
                        statusElement.innerHTML = `<span class="checkmate">Checkmate! ${enemyColor.charAt(0).toUpperCase() + enemyColor.slice(1)} wins!</span>`;
                        this.gameOver = true;
                        return;
                    } else {
                        statusElement.innerHTML = `<span class="check-warning">${this.currentPlayer.charAt(0).toUpperCase() + this.currentPlayer.slice(1)} is in check!</span>`;
                    }
                } else if (this.isStalemate(this.currentPlayer)) {
                    statusElement.innerHTML = 'Stalemate! The game is a draw.';
                    this.gameOver = true;
                    return;
                } else {
                    statusElement.textContent = '';
                }
                
                const playerText = this.isMultiplayer ? 
                    `${this.currentPlayer.charAt(0).toUpperCase() + this.currentPlayer.slice(1)}'s Turn` + 
                    (this.playerColor ? ` (You are ${this.playerColor})` : '') :
                    `${this.currentPlayer.charAt(0).toUpperCase() + this.currentPlayer.slice(1)}'s Turn`;
                    
                currentPlayerElement.textContent = playerText;
            }

            isCheckmate(color) {
                // If not in check, it's not checkmate
                const kingPos = this.kings[color];
                const enemyColor = color === 'white' ? 'black' : 'white';
                if (!this.isSquareAttacked(kingPos.row, kingPos.col, enemyColor)) {
                    return false;
                }
                
                // Check if any move can get out of check
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.color === color) {
                            const validMoves = this.getValidMoves(row, col);
                            if (validMoves.length > 0) {
                                return false;
                            }
                        }
                    }
                }
                
                return true;
            }

            isStalemate(color) {
                // If in check, it's not stalemate
                const kingPos = this.kings[color];
                const enemyColor = color === 'white' ? 'black' : 'white';
                if (this.isSquareAttacked(kingPos.row, kingPos.col, enemyColor)) {
                    return false;
                }
                
                // Check if any legal moves are available
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.color === color) {
                            const validMoves = this.getValidMoves(row, col);
                            if (validMoves.length > 0) {
                                return false;
                            }
                        }
                    }
                }
                
                return true;
            }

            updateCapturedPieces() {
                const whiteElement = document.getElementById('capturedWhite');
                const blackElement = document.getElementById('capturedBlack');
                
                whiteElement.innerHTML = this.capturedPieces.white
                    .map(piece => this.getPieceSymbol(piece))
                    .join(' ');
                    
                blackElement.innerHTML = this.capturedPieces.black
                    .map(piece => this.getPieceSymbol(piece))
                    .join(' ');
            }

            updateMoveHistory() {
                const movesList = document.getElementById('movesList');
                movesList.innerHTML = '';
                
                for (let i = 0; i < this.moveHistory.length; i += 2) {
                    const moveNumber = Math.floor(i / 2) + 1;
                    const whiteMove = this.moveHistory[i];
                    const blackMove = this.moveHistory[i + 1];
                    
                    // Move number
                    const numberElement = document.createElement('div');
                    numberElement.className = 'move-number';
                    numberElement.textContent = moveNumber + '.';
                    movesList.appendChild(numberElement);
                    
                    // White move
                    const whiteElement = document.createElement('div');
                    whiteElement.className = 'move-item white-move';
                    whiteElement.textContent = whiteMove ? whiteMove.notation : '';
                    movesList.appendChild(whiteElement);
                    
                    // Black move
                    const blackElement = document.createElement('div');
                    blackElement.className = 'move-item black-move';
                    blackElement.textContent = blackMove ? blackMove.notation : '';
                    movesList.appendChild(blackElement);
                }
                
                // Scroll to bottom
                movesList.scrollTop = movesList.scrollHeight;
            }
        }

        // Global game instance
        let game = new ChessGame();

        // Global functions for UI
        function resetGame() {
            if (game.isMultiplayer) {
                game.resetToLocal();
            }
            game = new ChessGame();
        }

        function showMultiplayerMenu() {
            document.getElementById('multiplayerModal').style.display = 'flex';
            document.getElementById('playerNameInput').focus();
        }

        function closeMultiplayerMenu() {
            document.getElementById('multiplayerModal').style.display = 'none';
            document.getElementById('joinGameSection').style.display = 'none';
        }

        function showJoinGameDialog() {
            document.getElementById('joinGameSection').style.display = 'block';
            document.getElementById('gameIdInput').focus();
        }

        async function createMultiplayerGame() {
            await game.createMultiplayerGame();
        }

        async function joinRandomGame() {
            await game.joinRandomGame();
        }

        async function joinSpecificGame() {
            await game.joinSpecificGame();
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (game.stompClient && game.connected) {
                game.disconnectFromServer();
            }
        });
    </script>
</body>
</html>